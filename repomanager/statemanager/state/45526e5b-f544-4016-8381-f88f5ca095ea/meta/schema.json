{
    "get_text_from_stream_response": "(provider, method, get_text_from_stream_response)",
    "_aretrieve": "(NodeWithScore, aretrieve, a function that retrieves a list of NodeWithScore objects)",
    "\"split_text\"": "(patch_token_splitter_newline_2, split_text, a method that splits text into sentences)\n(patch_token_splitter_newline_0, split_text, a method that splits text into tokens)",
    "get_table_columns": "(class name, method, method name and number of arguments)",
    "delete": "(Vector Store, delete_10, delete)",
    "\"llm\"": "(class name, method, method name)",
    "collection": "(collection_0, TypesenseVectorStore, collection)",
    "class-method": "(class name, method, a method definition that the class contains)",
    "_update_prompts": "(class name, method type, method name)",
    "_create_index": "(method name, method type, method definition)",
    "Method Goes Here: from_args": "(VectaraQueryEngine, REQUIRED_TYPE_2, Method Goes Here: from_args)",
    "flat_metadata": "(start node, edge type, end node) represents the relationship between different entities in the information graph. \n\nIn this case, the schema can be described as (entity A, edge type, entity B), where entity A is the starting node, edge type is the type of relationship between entity A and entity B, and entity B is the end node.",
    "_default_index_mapping": "(method name, method type, method definition)",
    "function-call": "(function name, function type, function call)",
    "Any]": "(start node, edge type, end node)",
    "_build_index_from_nodes": "(method name, method number, method description)",
    "completion_to_prompt": "(provider, completion_to_prompt, a relationship between a provider and a completion prompt)",
    "is_a_submodule_of": "(submodule name, is_a_submodule_of, parent submodule name)",
    "_retrieve": "(start node, edge type, end node)",
    "\"predict\"": "(function name, function definition, a function that is being patched)",
    "class": "(file name, class, a class definition that the file contains)",
    "from_uri": "(class name, method, a class method for creating an instance of the SQLDatabase class from a URI)",
    "_validate_index": "(method name, method type, method definition)",
    "__property__": "(SQLDatabase, dialect_0, __property__)",
    "get_request_body": "(provider, method, get_request_body)",
    "imports_directly": "(file name, edge type, import statement)",
    "PROPERTY": "(StorageContext, PROPERTY, vector_store_0, indices_3, retriever_modes_1, indices_5, retriever_modes_3, SummaryIndex, ref_doc_info_2, ref_doc_info_3)",
    "_select": "(start node, edge type, end node) represents the relationship between the start node and the end node, where the edge type describes the type of relationship.",
    "insert_into_table": "(class name, method, method name)",
    "get_single_table_info": "(class name, method, method name and its parameters)",
    "_insert": "(method name, method type, method definition)",
    "dir-to-file": "(directory name, dir-to-file, file name in the directory)",
    "EXTERNAL_DEPENDENCY": "(function name, function type, external dependency)",
    "client": "(entity, relationship, attribute)",
    "run_sql": "(class name, method, method name)",
    "_get_prompt_modules": "(BaseAgent, METHOD_1, _get_prompt_modules)\n(BaseAgent, METHOD_5, _get_prompt_modules)\n(KnowledgeGraphQueryEngine, None_151, _get_prompt_modules)\n(RetryGuidelineQueryEngine, None_179, _get_prompt_modules)\n\nSchema: (class name, method, a method that the class contains)",
    "get_response": "(method name, method type, method response)",
    "_create_index_if_not_exists": "(method name, method type, method definition)",
    "_query": "(BaseAgent, _query, a method in the BaseAgent class)\n(KnowledgeGraphQueryEngine, _query, a query method in the KnowledgeGraphQueryEngine class)\n(RetryGuidelineQueryEngine, _query, a query method in the RetryGuidelineQueryEngine class)",
    "root-to-dir": "(root directory, root-to-dir, paths in the base code directory)",
    "\"metadata\"": "(LLMPredictor, LLMMetadata(), metadata)\n(MockLLM, LLMMetadata(), metadata)",
    "_create_odata_filter": "(method name, method type, method definition)",
    "print_response_stream": "(Method_3, StreamingResponse, print_response_stream)",
    "agenerate_query": "(KnowledgeGraphQueryEngine, str_347, agenerate_query)",
    "max_tokens_key": "(provider, method, max_tokens_key)",
    "METHOD": "(class name, method name, method definition)",
    "ref_doc_info": "(method name, method type, reference document information)",
    "is_embedding_query": "(is_embedding_query, False, TypesenseVectorStore)",
    "function": "(file name, function, a function definition that the file contains)",
    "_get_prompts": "(class name, method, method name)",
    "as_retriever": "(method name, method number, method type)",
    "query": "(method name, query type, query)",
    "_create_upsert_docs": "(TypesenseVectorStore, _create_upsert_docs_0, _create_upsert_docs)",
    "REQUIRED_KEYS": "(SelectionOutputParser, frozenset(Answer.__annotations__), REQUIRED_KEYS)",
    "__init__": "(Class name, method/property name, method/property definition)",
    "add": "(vector store, method, method name)",
    "__str__": "(Method_4, StreamingResponse, __str__)",
    "dir-to-dir": "(start node, edge type, end node) (dir name, dir-to-dir, dir name)",
    "_create_metadata_index_fields": "(method name, method type, method definition)",
    "_normalise_metadata_to_index_fields": "(method name, method type, method description)",
    "class-instance": "(class name, method, an instance method of the class)",
    "arbitrary_types_allowed": "(start node, edge type, end node)",
    "\"split_text_metadata_aware\"": "(edge type, start node, end node)\n('patch_token_splitter_newline_3', 'SentenceSplitter', 'split_text_metadata_aware')\n('patch_token_splitter_newline_1', 'TokenTextSplitter', 'split_text_metadata_aware')\n\nSchema: (edge type, start node, end node)",
    "_create_index_document": "(method name, method type, method definition)",
    "get_text_from_response": "(provider, method, a method for getting text from a response)",
    "get_formatted_sources": "(method name, method type, method description)",
    "stores_text": "(typesense_vector_store, stores_text, True_0)",
    "REQUIRED_TYPE": "(start node, edge type, end node)",
    "messages_to_prompt": "(provider, edge type, optional messages_to_prompt)",
    "get_usable_table_names": "(class name, method, method name)",
    "_to_typesense_filter": "(typesense_vector_store, _to_typesense_filter_0, _to_typesense_filter)",
    "_aquery": "(RESPONSE_TYPE, _aquery, a query type)",
    "imports_from": "(file name, imports_from, module that is imported)",
    "_delete_node": "(method name, method type, method definition)",
    "Method Goes Here: aretrieve": "(VectaraQueryEngine, REQUIRED_TYPE_0, Method Goes Here: aretrieve)\n(VectaraQueryEngine, REQUIRED_TYPE_1, Method Goes Here: aretrieve)\n(VectaraQueryEngine, EXTERNAL_DEPENDENCY_0, Method Goes Here: aretrieve)\n\nExplanation: The schema represents the relationship between the VectaraQueryEngine and the different types of edges. The first edge type (REQUIRED_TYPE_0) indicates that the VectaraQueryEngine requires a method called \"aretrieve\". The second edge type (REQUIRED_TYPE_1) also indicates that the VectaraQueryEngine requires a method called \"aretrieve\". The third edge type (EXTERNAL_DEPENDENCY_0) indicates that the VectaraQueryEngine has an external dependency on a method called \"aretrieve\".",
    "_create_collection": "(entity, action, action description)",
    "\"apredict\"": "(patch_llmpredictor_apredict_0, apredict, apredict)",
    "Method Goes Here: with_retriever": "(VectaraQueryEngine, EXTERNAL_DEPENDENCY, Method Goes Here: with_retriever)",
    "generate_query": "(None_149, generate_query, a function that the KnowledgeGraphQueryEngine contains)"
}